2024-11-02 00:13:26,515 - log.py[38] - DEBUG: entry file content: ---------------------------------
2024-11-02 00:13:26,515 - log.py[39] - DEBUG: 
import glob
import os
import argparse
import time
import sys

sys.path.append(os.getcwd())

from multiprocessing import Manager
from cv_task.image_classification.cifar.models import resnet18
import torch
from legodnn.block_detection.model_topology_extraction import topology_extraction
from legodnn.presets.common_detection_manager_1204_new import CommonDetectionManager
from legodnn.model_manager.common_model_manager import CommonModelManager
from legodnn.presets.auto_block_manager import AutoBlockManager
from offload.deployment import OptimalRuntime, BlockProfiler
from legodnn.utils.dl.common.model import get_model_size
from offload.net.client import LegodnnDeployClient, LegodnnProfilesClient, LegodnnSendingClient, MoniterBWupClient, MoniterBWdownClient
from apscheduler.schedulers.background import BackgroundScheduler
import logging


parser = argparse.ArgumentParser()
parser.add_argument('--ip', type=str, help='ip地址', default='10.1.114.109')
parser.add_argument('--port', type=int, help='端口号', default=9999)
parser.add_argument('--path', type=str, help='保存路径', default='./results/legodnn')
parser.add_argument('--edge_device', type=str, help='使用设备', default='cpu')
parser.add_argument('--cloud_device', type=str, help='使用设备', default='cuda')
args = parser.parse_args()

logging.getLogger('apscheduler').setLevel(logging.WARNING)

def start_monitor_bwup(ip):
    monitor_ser = MoniterBWupClient(ip=ip, port=6666)
    monitor_ser.start()
    # monitor_ser.join()

def scheduler_for_bandwidth_monitor_bwup(ip, interval):
    # 创建调度器
    scheduler = BackgroundScheduler(timezone='MST')
    scheduler.add_job(start_monitor_bwup, 'interval', seconds=interval, args=[ip])
    scheduler.start()
    return scheduler

def start_monitor_bwdown(ip):
    monitor_cli = MoniterBWdownClient(ip=ip, port=6667)
    monitor_cli.start()

def scheduler_for_bandwidth_monitor_bwdown(ip, interval):
    # 创建调度器
    scheduler = BackgroundScheduler(timezone='MST')
    # 每隔 interval 秒就创建一个带宽监视进程 用来获取最新带宽
    scheduler.add_job(start_monitor_bwdown, 'interval', seconds=interval, args=[ip])
    scheduler.start()
    return scheduler

if __name__ == '__main__':
    torch.multiprocessing.set_start_method('spawn')

    cv_task = 'image_classification'
    dataset_name = 'cifar100'
    model_name = 'resnet18'
    method = 'legodnn'
    edge_device = args.edge_device
    cloud_device = args.cloud_device
    compress_layer_max_ratio = 0.125
    model_input_size = (1, 3, 32, 32)

    block_sparsity = [0.0, 0.2, 0.4, 0.6, 0.8]
    root_path = os.path.join(args.path, cv_task,
                             model_name + '_' + dataset_name + '_' + str(compress_layer_max_ratio).replace('.', '-'))

    compressed_blocks_dir_path = root_path + '/compressed'
    trained_blocks_dir_path = root_path + '/trained'
    descendant_models_dir_path = root_path + '/descendant'
    offload_dir_path = root_path + '/offload'
    block_training_max_epoch = 65
    test_sample_num = 100
    ip = args.ip
    # ip = '127.0.0.1'
    port = args.port

    # checkpoint = '/data/gxy/legodnn-auto-on-cv-models/cv_task_model/image_classification/cifar100/resnet18/2024-10-14/20-15-10/resnet18.pth'
    teacher_model = resnet18(num_classes=100).to(edge_device)
    # teacher_model.load_state_dict(torch.load(checkpoint)['net'])

    monitor_cli = MoniterBWupClient(ip=ip, port=6666, first=True)
    monitor_cli.start()
    monitor_cli.join()

    monitor_cli = MoniterBWdownClient(ip=ip, port=6667, first=True)
    monitor_cli.start()
    monitor_cli.join()

    scheduler_u = scheduler_for_bandwidth_monitor_bwup(ip, 3)
    scheduler_d = scheduler_for_bandwidth_monitor_bwdown(ip, 3)

    print('\033[1;36m-------------------------------->    BUILD LEGODNN GRAPH\033[0m')
    model_graph = topology_extraction(teacher_model, model_input_size, device=edge_device, mode='unpack')
    model_graph.print_ordered_node()

    print('\033[1;36m-------------------------------->    START BLOCK DETECTION\033[0m')
    detection_manager = CommonDetectionManager(model_graph, max_ratio=compress_layer_max_ratio)
    detection_manager.detection_all_blocks()
    detection_manager.print_all_blocks()

    model_manager = CommonModelManager()
    block_manager = AutoBlockManager(block_sparsity, detection_manager, model_manager)

    # print('\033[1;36m-------------------------------->    CHECK BLOCK PROFILES\033[0m')
    # p_client = LegodnnProfilesClient(ip, 9000, trained_blocks_dir_path)
    # p_client.start()
    # p_client.join()
    #
    # print('\033[1;36m-------------------------------->    START BLOCK PROFILING\033[0m')
    # edge_block_profiler = BlockProfiler(block_manager, model_manager, trained_blocks_dir_path, offload_dir_path, test_sample_num, model_input_size, edge_device, 'edge')
    # edge_block_profiler.profile_all_blocks()
    #
    # print('\033[1;36m-------------------------------->    TRANSMIT EDGE PROFILES\033[0m')
    # s_client = LegodnnSendingClient(ip, 9001, offload_dir_path)
    # s_client.start()
    # s_client.join()

    time.sleep(10)
    print('\033[1;36m-------------------------------->    START BLOCK INFERENCE\033[0m')
    scheduler_u.pause()
    scheduler_d.pause()
    res = Manager().dict()
    x = torch.rand((1, 64, 32, 32))
    # block = block_manager.get_block_from_file(
    #     os.path.join(trained_blocks_dir_path, block_manager.get_block_file_name('block-1', 0.8)),
    #     edge_device).to(edge_device)
    # block(x)
    d_client = LegodnnDeployClient(ip, port, x, block_manager, trained_blocks_dir_path, edge_device, res)
    d_client.start()
    d_client.join()

    print(res)

2024-11-02 00:13:26,515 - log.py[40] - DEBUG: entry file content: ---------------------------------
2024-11-02 00:13:26,641 - log.py[38] - DEBUG: entry file content: ---------------------------------
2024-11-02 00:13:26,641 - log.py[39] - DEBUG: 
import glob
import os
import argparse
import time
import sys

sys.path.append(os.getcwd())

from multiprocessing import Manager
from cv_task.image_classification.cifar.models import resnet18
import torch
from legodnn.block_detection.model_topology_extraction import topology_extraction
from legodnn.presets.common_detection_manager_1204_new import CommonDetectionManager
from legodnn.model_manager.common_model_manager import CommonModelManager
from legodnn.presets.auto_block_manager import AutoBlockManager
from offload.deployment import OptimalRuntime, BlockProfiler
from legodnn.utils.dl.common.model import get_model_size
from offload.net.client import LegodnnDeployClient, LegodnnProfilesClient, LegodnnSendingClient, MoniterBWupClient, MoniterBWdownClient
from apscheduler.schedulers.background import BackgroundScheduler
import logging


parser = argparse.ArgumentParser()
parser.add_argument('--ip', type=str, help='ip地址', default='10.1.114.109')
parser.add_argument('--port', type=int, help='端口号', default=9999)
parser.add_argument('--path', type=str, help='保存路径', default='./results/legodnn')
parser.add_argument('--edge_device', type=str, help='使用设备', default='cpu')
parser.add_argument('--cloud_device', type=str, help='使用设备', default='cuda')
args = parser.parse_args()

logging.getLogger('apscheduler').setLevel(logging.WARNING)

def start_monitor_bwup(ip):
    monitor_ser = MoniterBWupClient(ip=ip, port=6666)
    monitor_ser.start()
    # monitor_ser.join()

def scheduler_for_bandwidth_monitor_bwup(ip, interval):
    # 创建调度器
    scheduler = BackgroundScheduler(timezone='MST')
    scheduler.add_job(start_monitor_bwup, 'interval', seconds=interval, args=[ip])
    scheduler.start()
    return scheduler

def start_monitor_bwdown(ip):
    monitor_cli = MoniterBWdownClient(ip=ip, port=6667)
    monitor_cli.start()

def scheduler_for_bandwidth_monitor_bwdown(ip, interval):
    # 创建调度器
    scheduler = BackgroundScheduler(timezone='MST')
    # 每隔 interval 秒就创建一个带宽监视进程 用来获取最新带宽
    scheduler.add_job(start_monitor_bwdown, 'interval', seconds=interval, args=[ip])
    scheduler.start()
    return scheduler

if __name__ == '__main__':
    torch.multiprocessing.set_start_method('spawn')

    cv_task = 'image_classification'
    dataset_name = 'cifar100'
    model_name = 'resnet18'
    method = 'legodnn'
    edge_device = args.edge_device
    cloud_device = args.cloud_device
    compress_layer_max_ratio = 0.125
    model_input_size = (1, 3, 32, 32)

    block_sparsity = [0.0, 0.2, 0.4, 0.6, 0.8]
    root_path = os.path.join(args.path, cv_task,
                             model_name + '_' + dataset_name + '_' + str(compress_layer_max_ratio).replace('.', '-'))

    compressed_blocks_dir_path = root_path + '/compressed'
    trained_blocks_dir_path = root_path + '/trained'
    descendant_models_dir_path = root_path + '/descendant'
    offload_dir_path = root_path + '/offload'
    block_training_max_epoch = 65
    test_sample_num = 100
    ip = args.ip
    # ip = '127.0.0.1'
    port = args.port

    # checkpoint = '/data/gxy/legodnn-auto-on-cv-models/cv_task_model/image_classification/cifar100/resnet18/2024-10-14/20-15-10/resnet18.pth'
    teacher_model = resnet18(num_classes=100).to(edge_device)
    # teacher_model.load_state_dict(torch.load(checkpoint)['net'])

    monitor_cli = MoniterBWupClient(ip=ip, port=6666, first=True)
    monitor_cli.start()
    monitor_cli.join()

    monitor_cli = MoniterBWdownClient(ip=ip, port=6667, first=True)
    monitor_cli.start()
    monitor_cli.join()

    scheduler_u = scheduler_for_bandwidth_monitor_bwup(ip, 3)
    scheduler_d = scheduler_for_bandwidth_monitor_bwdown(ip, 3)

    print('\033[1;36m-------------------------------->    BUILD LEGODNN GRAPH\033[0m')
    model_graph = topology_extraction(teacher_model, model_input_size, device=edge_device, mode='unpack')
    model_graph.print_ordered_node()

    print('\033[1;36m-------------------------------->    START BLOCK DETECTION\033[0m')
    detection_manager = CommonDetectionManager(model_graph, max_ratio=compress_layer_max_ratio)
    detection_manager.detection_all_blocks()
    detection_manager.print_all_blocks()

    model_manager = CommonModelManager()
    block_manager = AutoBlockManager(block_sparsity, detection_manager, model_manager)

    # print('\033[1;36m-------------------------------->    CHECK BLOCK PROFILES\033[0m')
    # p_client = LegodnnProfilesClient(ip, 9000, trained_blocks_dir_path)
    # p_client.start()
    # p_client.join()
    #
    # print('\033[1;36m-------------------------------->    START BLOCK PROFILING\033[0m')
    # edge_block_profiler = BlockProfiler(block_manager, model_manager, trained_blocks_dir_path, offload_dir_path, test_sample_num, model_input_size, edge_device, 'edge')
    # edge_block_profiler.profile_all_blocks()
    #
    # print('\033[1;36m-------------------------------->    TRANSMIT EDGE PROFILES\033[0m')
    # s_client = LegodnnSendingClient(ip, 9001, offload_dir_path)
    # s_client.start()
    # s_client.join()

    time.sleep(10)
    print('\033[1;36m-------------------------------->    START BLOCK INFERENCE\033[0m')
    scheduler_u.pause()
    scheduler_d.pause()
    res = Manager().dict()
    x = torch.rand((1, 64, 32, 32))
    # block = block_manager.get_block_from_file(
    #     os.path.join(trained_blocks_dir_path, block_manager.get_block_file_name('block-1', 0.8)),
    #     edge_device).to(edge_device)
    # block(x)
    d_client = LegodnnDeployClient(ip, port, x, block_manager, trained_blocks_dir_path, edge_device, res)
    d_client.start()
    d_client.join()

    print(res)

2024-11-02 00:13:26,641 - log.py[40] - DEBUG: entry file content: ---------------------------------
